import threadingimport uuidimport timeimport jsonimport pytzimport stripeimport stringimport osimport reimport copyfrom urlparse import parse_qsfrom dateutil.relativedelta import relativedeltafrom datetime import datetime, timedeltafrom django.core.cache import get_cachefrom django.db import IntegrityErrorfrom django.http.response import HttpResponsefrom django.views.generic import Viewfrom django.contrib.auth.models import Userfrom django.conf import settingsfrom utils import paypal, elasticfrom utils.smtp2go import send_mailfrom proxmate.models import Signer, Package, Server, Message, Payment, check_key, PaypalIPNLog, StripeWebhookLog, PackageHost, Subscriptionpay_pal = paypal.PayPal()message_cache = get_cache('message')package_version_cache = get_cache('packages_version')server_list_cache = get_cache('server_list')daily_check_cache = get_cache('daily_check')class StatusApi(View):    @staticmethod    def get(request, key):        """        This API method returns the user account stats.        API endpoint: /api/status/<key>/        :param request: The request object doesn't receive any GET parameters.        :param key: The key is get from the URL path.        :return: Returns JSON with account status.        """        if not check_key(key):            return HttpResponse(                json.dumps({                    'success': False,                    'error': 'invalid_key'                }), content_type="application/json"            )        data = Signer.loads(key)        try:            user = User.objects.get(username=data['email'])        except User.DoesNotExist:            return HttpResponse(                json.dumps({                    'success': False,                })            )        return HttpResponse(            json.dumps({                'success': True,                'data': {                    'plan_expiration_date': time.mktime(user.profile.plan_expiration_date.timetuple()),                    'plan_status': user.profile.plan_status,                    'subscription_status': user.profile.subscription_status,                    'payment_status': user.profile.payment_status,                    'subscription_supplier': user.profile.subscription_supplier,                    'subscription_name': settings.PROXMATE_PLANS[user.profile.plan_status]['name'],                    'email': user.email,                    'username': user.username,                },                'dat_end': {                    'plan_expiration_date': time.mktime(user.profile.plan_expiration_date.timetuple()),                    'plan_status': user.profile.plan_status,                    'subscription_status': user.profile.subscription_status,                    'payment_status': user.profile.payment_status,                    'subscription_supplier': user.profile.subscription_supplier,                    'subscription_name': settings.PROXMATE_PLANS[user.profile.plan_status]['name'],                    'email': user.email,                    'username': user.username,                }            }), content_type="application/json"        )    @staticmethod    def post(request, key):        """        This API method receives daily beacons for reporting        API endpoint: /api/status/<key>/        :param request: The request object gets the following POST parameters:                        - check_type: status daily update type (e.g. channel, daily)                        - day_string_check: string to identify the date beacon was sent        :param key: The key is get from the URL path.        :return: Returns JSON with result.        """        # check key validity        if not check_key(key):            return HttpResponse(                json.dumps({                    'success': False,                    'error': 'invalid_key'                }), content_type="application/json"            )        check_type = request.POST.get('check')        day_string_check = request.POST.get('day_check')        data = Signer.loads(key)        try:            user = User.objects.get(username=data['email'])        except User.DoesNotExist:            return HttpResponse(                json.dumps({                    'success': False,                })            )        # get value from cache        cache_auth = "" + str(user.id) + '_' + check_type        cached_string = daily_check_cache.get(cache_auth)        # process beacon for active user        if check_type == 'channel':            if not cached_string:                # if not in cache get value from database                cached_string = user.profile.last_channel_check            if day_string_check != cached_string or cached_string == 'None':                # save new string to database                user.profile.last_channel_check = day_string_check                user.profile.save()                # set new string to cache                daily_check_cache.set(cache_auth, day_string_check)                elastic.ElasticThread(index='plugin_beacon', doc_type='channel_check', user=user, req=request).start()        # process beacon for plugin installed        if check_type == 'daily':            if not cached_string:                # if not in cache get value from database                cached_string = user.profile.last_active_check            # check if received string matches existing            if day_string_check != cached_string or cached_string == 'None':                # save new string to database                user.profile.last_active_check = day_string_check                user.profile.save()                # set new string to cache                daily_check_cache.set(cache_auth, day_string_check)                # log beacon for reporting                elastic.ElasticThread(index='plugin_beacon', doc_type='daily_check', user=user, req=request).start()        return HttpResponse(            json.dumps({                'success': True,            }), content_type="application/json"        )class FeedbackApi(View):    @staticmethod    def post(request):        """        This API method sends feedback email        API endpoint: /api/feedback/        :param request: The request object gets the following POST parameters:                        - content: message content                        - category: feedback category (e.g. channel request)                        - email: user email        :return: Returns JSON with status.        """        content = request.POST.get('message')        category = request.POST.get('category')        email = request.POST.get('email')        # send email with received data        send_mail(            subject='[ ' + category + ' ] Proxmate Feedback',            plain_content='From: ' + email + '\n\n Message: \n\n' + content,            html_content='From: ' + email + '\n\n Message: \n\n' + content,            to_list='support@prox-mate.zendesk.com',            from_list=email        )        return HttpResponse(            json.dumps({                'success': True,            }), content_type="application/json")class UserApi(View):    @staticmethod    def post(request):        """        This API method requires creation of a new user.        API endpoint: /api/user/activation/require/        :param request: The request object gets the following POST parameters:                        - email: email to create account for                        - browser: browser requesting instalation from                        - is_update: specifies if this is an updated user        :return: Returns JSON with account status.        """        email = request.POST.get('email')        browser = request.POST.get('browser')        is_update = request.POST.get('is_update')        # Migrated user from old proxmate        if is_update:            # Create random uuid for user and put it in the database            _uuid = str(uuid.uuid4())            user = User.objects.create_user(                username=_uuid            )            # create activation link            activation_link = Signer.dumps(email=_uuid, browser=browser)            # TODO create user automatically inactive            user.is_active = False            user.save()            # set activation link            user.profile.activation_code = activation_link            user.profile.is_updated_user = True            # set subscription parameters            user.profile.plan_expiration_date = datetime.now() + timedelta(days=30)            user.profile.plan_status = 'free_plan_1m'            user.profile.subscription_status = 'trial'            user.profile.save()            # log user creation            elastic.ElasticThread(doc_type='user_create', user=user, req=request).start()            return HttpResponse(                json.dumps({                    'success': True,                    'is_update': True,                    'update_token': user.username,                    'api_key': activation_link,                }), content_type="application/json")        # no email parameter        if not email:            return HttpResponse(                json.dumps({                    'success': False,                    'error': 'empty_credentials'                }), content_type="application/json"            )        # check if user is an updated user        updated_users_check = User.objects.filter(            email=email        )        # if user is updated        if updated_users_check and updated_users_check.count:            for user in updated_users_check:                if user.email != user.username:                    email = user.username        try:            # create the user            user = User.objects.create_user(                username=email,                email=email            )            # log user creation            elastic.ElasticThread(doc_type='user_create', user=user, req=request).start()        except IntegrityError:            # user already exists            user = User.objects.get(                username=email            )            # there is an existing user so there is a retrieval            activation_link = Signer.dumps(email=email, browser=browser)            # set new activation link            user.profile.activation_code = activation_link            user.profile.save()            # log user retrieval            elastic.ElasticThread(doc_type='user_retrieval', user=user, req=request).start()            # get activation template            with open('/opt/proxmate/static/emails/activation_inline.html') as email_file:                email_template = string.Template(email_file.read())            # create activation link            activation_link = settings.WEBSITE_URL + 'confirm/' + activation_link + '/'            # populate email template with data            html_message = email_template.safe_substitute(                emailneeded=str(user.email),                buttonlink=str(activation_link),                hreflink=str(activation_link),                activationstring=str(activation_link)            )            # send email            send_mail(subject='Proxmate Activation Link',                      plain_content='',                      html_content=html_message,                      to_list=user.email,                      from_list='support@proxmate.me')            return HttpResponse(                json.dumps({                    'success': False,                    'activation_link': activation_link,                    'error': 'user_exists'                }), content_type="application/json"            )        # user was just created make user inactive        user.is_active = False        user.save()        # create activation link        activation_link = Signer.dumps(email=email, browser=browser)        # save activation link        user.profile.activation_code = activation_link        user.profile.save()        # get activation template        with open('/opt/proxmate/static/emails/activation_inline.html') as email_file:            email_template = string.Template(email_file.read())        # create activation link        activation_link = settings.WEBSITE_URL + 'confirm/' + activation_link + '/'        # populate email template with data        html_message = email_template.safe_substitute(            emailneeded=str(user.email),            buttonlink=str(activation_link),            hreflink=str(activation_link),            activationstring=str(activation_link)        )        # send email        send_mail(            subject='Proxmate Activation Link',            plain_content='',            html_content=html_message,            to_list=user.email,            from_list='support@proxmate.me')        return HttpResponse(            json.dumps({                'success': True,                'activation_link': activation_link            }), content_type="application/json")    @staticmethod    def get(request, key):        """        This API method requires creation of a new user.        API endpoint: /api/user/confirm/<key>/        :param request: The request object doesn't receive any GET parameters.        :param key: The key is get from the URL path.        :return: Returns JSON with account status for visual representations.        """        try:            # check key for expiration            email = Signer.loads(key, max_age=7200)        except KeyError:            # key expired            return HttpResponse(                json.dumps({                    'success': False,                    'error': 'key_expired'                }), content_type="application/json"            )        except ValueError:            # key is invalid/broken/fake            return HttpResponse(                json.dumps({                    'success': False,                    'error': 'key_invalid'                }), content_type="application/json"            )        try:            # get user based on key            user = User.objects.get(username=email['email'])        except User.DoesNotExist:            return HttpResponse(                json.dumps({                    'success': False,                    'error': 'email_not_found',                })            )        # key used for activation is invalid        if user.profile.activation_code != key:            return HttpResponse(                json.dumps({                    'success': False,                    'error': 'key_not_found'                }), content_type="application/json"            )        if not user.is_active:            # apply 14 days trial            if not user.profile.plan_status:                user.profile.plan_expiration_date = datetime.now() + timedelta(days=14)                user.profile.plan_status = 'free_plan_14d'                user.profile.subscription_status = 'trial'                user.profile.save()            # remove activation code and set active            user.profile.activation_code = ''            user.profile.save()            user.is_active = True            user.save()            # log activation            elastic.ElasticThread(doc_type='user_activate', user=user, req=request).start()            return HttpResponse(                json.dumps({                    'success': True,                    'action': 'activation',                    'data': email                }), content_type="application/json")        # if account expired it will take user to pricing else on channels        if datetime.now(pytz.utc) > user.profile.plan_expiration_date:            action = 'retrieval_expired'        else:            action = 'retrieval'        return HttpResponse(            json.dumps({                'success': True,                'action': action,                'subscription_status': user.profile.subscription_status,                'plan_expiration_date': time.mktime(user.profile.plan_expiration_date.timetuple()),                'data': email            }), content_type="application/json")class PackageList(View):    @staticmethod    def get(request, key):        """        This API method returns all the packages versions.        API endpoint: /api/package/update/<key>/        :param request: The request object doesn't receive any GET parameters.        :param key: The key is get from the URL path.        :return: Returns JSON with list of packages versions.        """        if not check_key(key):            return HttpResponse(                json.dumps({}), content_type="application/json")        # try get them from cache        _packages = package_version_cache.get('latest')        if not _packages:            # get all public packages            packages = Package.objects.filter(is_private=False)            _packages = {}            for package in packages:                _packages[package.id] = {                    'version': package.version                }            # set new list in cache            package_version_cache.set('latest', _packages)        return HttpResponse(            json.dumps(_packages), content_type="application/json")class ProxyAPINew(View):    @staticmethod    def get(request):        """        This API method V2.0 returns whitelist for the proxy servers.        This will replace the older version as is more efficient.        API endpoint: /api/proxy/whitelist_new/        :param request: The request object doesn't receive any GET parameters.        :return: Returns JSON with list of whitelisted domains for proxy servers.        """        packages = Package.objects.all()        whitelist = {}        def add_host_to_whitelist(host):            # Check if there is already a wildcard entry covering the current host            if "." + host in whitelist:                return            # Check if the current element is a wildcard host (*.foo.com, .foo.com)            if "*." in host or host.startswith("."):                # If has *. wildcard remove * for squid configuration                wildcard_host = host.replace("*", "")                # check if any other                for we in copy.copy(whitelist):                    if wildcard_host in we or "." + we == wildcard_host:                        del whitelist[we]                whitelist[wildcard_host] = True            else:                # check if this is                for key in whitelist:                    if key.startswith(".") and key in host:                        return                whitelist[host] = True        for package in packages:            # loop all the routes to add the hosts associated            for route in package.packageroute_set.all():                # get only the host not the regexp matches or startswith                if route.type == 'host':                    add_host_to_whitelist(route.route)            # loop all the hosts to add them to the whitelist            for host in package.packagehost_set.all():                add_host_to_whitelist(host.host)        # send only the keys of the whitelist object        return HttpResponse(            json.dumps(whitelist.keys()), content_type="application/json")class ProxyAPI(View):    @staticmethod    def get(request):        """        This API method returns whitelist for the proxy servers.        This will be replaced by a new version.        API endpoint: /api/proxy/whitelist/        :param request: The request object doesn't receive any GET parameters.        :return: Returns JSON with list of domains for proxy servers to use as whitelist        """        packages = Package.objects.all()        whitelist = {}        for package in packages:            for route in package.packageroute_set.all():                if route.type == 'host':                    whitelist[route.route] = True            for host in package.packagehost_set.all():                if "youtube" in host.host or "googlevideo" in host.host:                    if "*" in host.host:                        host.host = host.host.replace("*", "")                    whitelist[host.host] = True        return HttpResponse(            json.dumps(whitelist.keys()), content_type="application/json")class PackageAPI(View):    @staticmethod    def get(request, package_id, key):        """        This API method returns one package .        This will be replaced by a method that returns multiple packages.        API endpoint: /api/package/install/<package_id>/<key>/        :param request: The request object doesn't receive any GET parameters.        :param package_id: Id of the package to be retrieved which is get from URL path        :param key: The key is get from the URL path.        :return: Returns JSON object with package data        """        package = Package.objects.get(pk=package_id)        _routes = []        _additional_countries = []        for route in package.packageroute_set.all():            if route.type == 'host':                _routes.append(                    {                        "host": route.route,                        "contains": [],                        "startsWith": ""                    }                )            elif route.type == 'contains':                _routes.append(                    {                        "host": "",                        "contains": [route.route],                        "startsWith": ""                    }                )            elif route.type == 'shExpMatch':                _routes.append(                    {                        "host": "",                        "contains": [route.route],                        "startsWith": ""                    }                )        # A package can be switched between multiple servers/countries        if package.allow_multiple_countries:            _additional_countries.append({"short_hand": package.country.short_hand, "title": package.country.title})            for country in package.additional_countries.all():                _additional_countries.append({"short_hand": country.short_hand, "title": country.title})        _package = {            'id': package.id,            'name': package.name,            'version': package.version,            'smallIcon': package.small_icon.url,            'pageUrl': package.page_url,            'country': package.country.short_hand,            'contentScripts': [],            'additional_countries': _additional_countries,            'allow_multiple_countries': package.allow_multiple_countries,            'hosts': [],            'routing': _routes,        }        return HttpResponse(            json.dumps(_package), content_type="application/json")    @staticmethod    def post(request, key):        """        This API method returns multiple packages.        API endpoint: /api/package/install/<key>/        :param request: The request object gets the following POST parameters:                        - packages: list of packages to be retrieved        :param key: The key is get from the URL path.        :return: Returns JSON object with required packages data        """        package_list = []        for package_id in json.loads(request.POST.get('packages')):            package_list.append(int(package_id))        routes = {}        packages = []        common = {}        for package in Package.objects.filter(id__in=package_list):            _routes = []            _additional_countries = []            for route in package.packageroute_set.all():                if package.country.short_hand not in routes:                    routes[package.country.short_hand] = {}                if route.route in routes[package.country.short_hand]:                    common[route.route].append({                        'channel': package.name,                        'country': package.country.title,                    })                    continue                if route.route not in common:                    common[route.route] = []                else:                    common[route.route].append({                        'channel': package.name,                        'country': package.country.title,                    })                routes[package.country.short_hand][route.route] = package                if route.type == 'host':                    _routes.append(                        {                            "host": route.route,                            "contains": [],                            "startsWith": ""                        }                    )                elif route.type == 'contains':                    _routes.append(                        {                            "host": "",                            "contains": [route.route],                            "startsWith": ""                        }                    )                elif route.type == 'shExpMatch':                    _routes.append(                        {                            "host": "",                            "contains": [route.route],                            "startsWith": ""                        }                    )            content_scripts = []            for content_script in package.contentscript_set.all():                content_scripts.append({                    'match': content_script.match,                    'script': content_script.script                })            hosts = []            for host in package.packagehost_set.all():                hosts.append(host.host)            if package.allow_multiple_countries:                _additional_countries.append({"short_hand": package.country.short_hand, "title": package.country.title})                for country in package.additional_countries.all():                    _additional_countries.append({"short_hand": country.short_hand, "title": country.title})            _package = {                'id': package.id,                'name': package.name,                'version': package.version,                'smallIcon': package.small_icon.url,                'pageUrl': package.page_url,                'country': package.country.short_hand,                'additional_countries': _additional_countries,                'allow_multiple_countries': package.allow_multiple_countries,                'hosts': hosts,                'routing': _routes,                'contentScripts': content_scripts            }            packages.append(_package)        return HttpResponse(            json.dumps(packages), content_type="application/json")class ServerList(View):    @staticmethod    def get(request, key):        """        This API method returns proxy list servers.        API endpoint: /api/server/list/<key>/        :param request: The request object gets the following POST parameters:                        - api_v: version of the plugin to send specific data in different cases        :param key: The key is get from the URL path.        :return: Returns JSON object with list of active servers        """        version = request.GET.get('api_v')        if not check_key(key):            return HttpResponse(                json.dumps({                    'success': False,                    'error': 'invalid_key'                }), content_type="application/json")        # get data from cache        if version:            _servers = server_list_cache.get('version')        else:            _servers = server_list_cache.get('latest')        if not _servers:            # get data as it is not present in cache            servers = Server.objects.filter(is_private=False)            _servers = []            for server in servers:                # patch for newer version                if not version:                    server.return_type = 'HTTPS'                    server.port = '443'                _servers.append({                    "host": server.host,                    "port": server.port,                    "user": server.user,                    "password": server.password,                    "country": server.country.short_hand,                    "ip": server.ip,                    "return_type": server.return_type                })            # put data in cache            if version:                server_list_cache.set('version', _servers)            else:                server_list_cache.set('latest', _servers)        return HttpResponse(            json.dumps(_servers), content_type="application/json")class StripeApi(View):    @staticmethod    def post(request):        """        This API method deals with stripe payments.        API endpoint: /stripe/        :param request: The request object gets the following POST parameters:                        - token: token generated from stripe containing                        - plugin_key: user key                        - plan: selected plan by the user        :return: Returns JSON object with success status of the API execution        """        token = json.loads(request.POST.get('token'))        plugin_key = request.POST.get('key')        plan = request.POST.get('plan')        try:            key_json = Signer.loads(plugin_key)        except ValueError:            return HttpResponse(                json.dumps({                    'success': False,                    'error': 'api_key_not_sent'                }), content_type="application/json"            )        try:            proxmate_user = User.objects.get(username=key_json['email'])        except User.DoesNotExist:            return HttpResponse(                json.dumps({                    'success': False,                    'error': 'Wrong Email'                }), content_type="application/json"            )        # One-Off Payment        if plan == 'proxmate_yearly_1195':            # user is new to stripe            if not proxmate_user.profile.stripe_customer_id:                # create user based on token                customer = stripe.Customer.create(                    description="Customer for " + token['email'],                    email=token["email"],                    source=token['id']  # obtained with Stripe.js                )                try:                    # try the charge                    stripe.Charge.create(                        amount=1195,  # in cents                        currency="usd",                        customer=customer.id                    )                except stripe.error.CardError, e:                    # The card has been declined                    return HttpResponse(                        json.dumps({                            'success': False,                            'error': 'declined_card'                        }), content_type="application/json"                    )                # is existing user so attach email                if not proxmate_user.email:                    proxmate_user.email = token['email']                    proxmate_user.save()                # set subscription data                proxmate_user.profile.plan_status = plan                proxmate_user.profile.stripe_customer_id = customer.id                proxmate_user.profile.payment_status = 'pending'                proxmate_user.profile.subscription_status = 'subscription_canceled'                proxmate_user.profile.subscription_supplier = 'stripe'                proxmate_user.profile.save()            else:                # he already has a customer id                customer = stripe.Customer.retrieve(proxmate_user.profile.stripe_customer_id)                try:                    # try the charge                    stripe.Charge.create(                        amount=1195,                        currency="usd",                        customer=customer.id                    )                except stripe.error.CardError, e:                    # The card has been declined                    return HttpResponse(                        json.dumps({                            'success': False,                            'error': 'declined_card'                        }), content_type="application/json"                    )                # set subscription data                proxmate_user.profile.plan_status = plan                proxmate_user.profile.stripe_customer_id = customer.id                proxmate_user.profile.payment_status = 'pending'                proxmate_user.profile.subscription_status = 'subscription_canceled'                proxmate_user.profile.subscription_supplier = 'stripe'                proxmate_user.profile.save()            # get email template            with open('/opt/proxmate/static/emails/confirmation_one_off_inline.html') as email_file:                email_template = string.Template(email_file.read())            # populate template            html_message = email_template.safe_substitute(                subscribedemail=str(proxmate_user.email),                subsctiptionperiod=str(settings.PROXMATE_PLANS[proxmate_user.profile.plan_status]['period_name']),                startdate=datetime.now().strftime("%d %B %Y"),                paymentplan=str(settings.PROXMATE_PLANS[proxmate_user.profile.plan_status]['price_string'])            )            # send email            send_mail(subject='Proxmate Payment Confirmation',                      plain_content='',                      html_content=html_message,                      to_list=proxmate_user.email,                      from_list='support@proxmate.me')            return HttpResponse(                json.dumps({                    'success': True                }), content_type="application/json"            )        else:            if not proxmate_user.profile.stripe_customer_id:                stripe_plan = stripe.Plan.retrieve(plan)                if not stripe_plan:                    return HttpResponse(                        json.dumps({                            'success': False,                            'error': 'Wrong Plan'                        }), content_type="application/json"                    )                try:                    # create customer based on token and plan selected ( this will also create the subscription)                    customer = stripe.Customer.create(                        description="Customer for " + token['email'],                        email=token["email"],                        plan=plan,                        trial_end='now',                        source=token['id']  # obtained with Stripe.js                    )                except Exception as Err:                    return HttpResponse(                        json.dumps({                            'success': False,                            'error': 'declined_card'                        }), content_type="application/json"                    )                if not proxmate_user.email:                    proxmate_user.email = token['email']                    proxmate_user.save()                # set subscription data                proxmate_user.profile.plan_status = plan                proxmate_user.profile.stripe_customer_id = customer.id                proxmate_user.profile.payment_status = 'pending'                proxmate_user.profile.subscription_status = 'subscribed'                proxmate_user.profile.subscription_supplier = 'stripe'                proxmate_user.profile.save()            else:                # he has customer id so retrieve it                customer = stripe.Customer.retrieve(proxmate_user.profile.stripe_customer_id)                # get all subscriptions                subscriptions = customer.subscriptions.all()                # check for active subscription                for subscription in subscriptions.data:                    if subscription.status == 'active':                        if subscription.cancel_at_period_end == False:                            return HttpResponse(                                json.dumps({                                    'success': False,                                    'error': 'already_subscribed'                                }), content_type="application/json"                            )                        subscription.cancel_at_period_end = True                # get the plan from stripe                stripe_plan = stripe.Plan.retrieve(plan)                if not stripe_plan:                    return HttpResponse(                        json.dumps({                            'success': False,                            'error': 'Wrong Plan'                        }), content_type="application/json"                    )                try:                    #  try to create the new subscription                    customer.subscriptions.create(                        plan=plan,                        trial_end='now',                        source=token['id']  # obtained with Stripe.js                    )                except Exception as Err:                    return HttpResponse(                        json.dumps({                            'success': False,                            'error': 'declined_card'                        }), content_type="application/json"                    )                # set subscription data                proxmate_user.profile.plan_status = plan                proxmate_user.profile.stripe_customer_id = customer.id                proxmate_user.profile.payment_status = 'pending'                proxmate_user.profile.subscription_status = 'subscribed'                proxmate_user.profile.subscription_supplier = 'stripe'                proxmate_user.profile.save()            # get email template            with open('/opt/proxmate/static/emails/confirmation_inline.html') as email_file:                email_template = string.Template(email_file.read())            # populate template            html_message = email_template.safe_substitute(                subscribedemail=str(proxmate_user.email),                subsctiptionperiod=str(settings.PROXMATE_PLANS[proxmate_user.profile.plan_status]['period_name']),                startdate=datetime.now().strftime("%d %B %Y"),                paymentplan=str(settings.PROXMATE_PLANS[proxmate_user.profile.plan_status]['price_string'])            )            # send email            send_mail(subject='Proxmate Subscription Confirmation',                      plain_content='',                      html_content=html_message,                      to_list=proxmate_user.email,                      from_list='support@proxmate.me')            return HttpResponse(                json.dumps({                    'success': True                }), content_type="application/json"            )class StripeWebhook(View):    @staticmethod    def post(request):        """        This API handles webhooks from Stripe        API endpoint: /webhook/stripe/        :param request: The request object has multiple variables from stripe.        :return: Returns JSON object with success status of the API execution        """        # log the ipn call        StripeWebhookLog.objects.create(webhook_message=request.body)        event_json = json.loads(request.body)        # charge for One-Off Payment        if event_json["type"] == 'charge.succeeded':            if not event_json["data"]["object"]["amount"] == 1195:                return HttpResponse(status=200)            invoice = event_json['data']["object"]            # get customer            customer = stripe.Customer.retrieve(invoice["customer"])            # get user            try:                proxmate_user = User.objects.get(profile__stripe_customer_id=customer.id)            except:                return HttpResponse(status=200)            # plan for One-Off Payment            plan = 'proxmate_yearly_1195'            if proxmate_user.profile.plan_expiration_date > datetime.now(pytz.utc):                # Still has some days left add to those                days = settings.PROXMATE_PLANS[plan]['period']                proxmate_user.profile.plan_expiration_date = proxmate_user.profile.plan_expiration_date + timedelta(days=days)            else:                # has no days left so the subscription starts now                days = settings.PROXMATE_PLANS[plan]['period']                proxmate_user.profile.plan_expiration_date = datetime.now(pytz.utc) + timedelta(days=days)            # update subscription data            proxmate_user.profile.subscription_supplier = 'stripe'            # set as cancelled because there is no subscription            proxmate_user.profile.subscription_status = 'subscription_canceled'            proxmate_user.profile.plan_status = 'proxmate_yearly_1195'            proxmate_user.profile.payment_status = 'paid'            proxmate_user.profile.save()            # save to payments            Payment.objects.create(                user=proxmate_user,                currency=invoice["currency"],                amount=invoice['amount'],                transaction_date=datetime.fromtimestamp(float(invoice['created'])),                transaction_id=invoice['id'],                payer_email=customer['email'],                description="Yearly One-time",                subscription_plan='proxmate_yearly_1195',                subscription_id='None'            )            # save subscription            Subscription.objects.create(                user=proxmate_user,                payer_email=customer['email'],                description="Yearly One-time",                subscription_plan='proxmate_yearly_1195',                subscription_id='None',                supplier="stripe"            )        if event_json["type"] == 'invoice.payment_succeeded':            invoice = event_json['data']["object"]            customer = stripe.Customer.retrieve(invoice["customer"])            # get user            try:                proxmate_user = User.objects.get(profile__stripe_customer_id=customer.id)            except:                return HttpResponse(status=200)            # get subscritpion and plan for the payment            subscription = customer.subscriptions.retrieve(invoice["subscription"])            plan = subscription["plan"]            if proxmate_user.profile.plan_expiration_date > datetime.now(pytz.utc):                # Still has some days left so add to those                days = settings.PROXMATE_PLANS[plan["id"]]['period']                proxmate_user.profile.plan_expiration_date = proxmate_user.profile.plan_expiration_date + timedelta(days=days)            else:                # has no days left so the subscription starts now                days = settings.PROXMATE_PLANS[plan["id"]]['period']                proxmate_user.profile.plan_expiration_date = datetime.now(pytz.utc) + timedelta(days=days)            # add subscription data            proxmate_user.profile.subscription_supplier = 'stripe'            proxmate_user.profile.subscription_status = 'subscribed'            proxmate_user.profile.plan_status = plan['id']            proxmate_user.profile.payment_status = 'paid'            proxmate_user.profile.save()            # save to payments            Payment.objects.create(                user=proxmate_user,                currency=invoice["currency"],                amount=invoice['total'],                transaction_date=datetime.fromtimestamp(float(invoice['date'])),                transaction_id=invoice['id'],                payer_email=customer['email'],                description=plan["name"],                subscription_plan=plan["id"],                subscription_id=subscription["id"]            )        if event_json["type"] == 'customer.subscription.created':            subscription = event_json["data"]["object"]            plan = subscription["plan"]            # get user for subscription            proxmate_user = User.objects.get(profile__stripe_customer_id=subscription["customer"])            # check if subscription was not updated( 'sometimes payment comes first and sets that up')            if proxmate_user.profile.stripe_subscription_id != subscription['id']:                proxmate_user.profile.stripe_subscription_id = subscription['id']                proxmate_user.profile.plan_status = plan['id']                proxmate_user.profile.subscription_status = 'subscribed'                proxmate_user.profile.subscription_supplier = 'stripe'                proxmate_user.profile.save()            # save subscription            Subscription.objects.create(                user=proxmate_user,                payer_email=proxmate_user.email,                description=plan["name"],                subscription_plan=plan["id"],                subscription_id=subscription["id"],                supplier="stripe"            )        # print 'COMPLETED: ', event_json["type"]        return HttpResponse(status=200)class PayPalWebhook(View):    @staticmethod    def post(request):        """        This API handles IPNs from PayPal        API endpoint: /webhook/paypal/        :param request: The request object has multiple variables from Paypal.        :return: Returns JSON object with success status of the API execution        """        # save raw data to log        ipn_data = request.body        PaypalIPNLog.objects.create(ipn_message=ipn_data)        data = dict((k, v if len(v) > 1 else v[0])                    for k, v in parse_qs(ipn_data).iteritems())        # verify the ipn        if not paypal.verify_ipn(data):            return HttpResponse(status=200)        if data['txn_type'] == 'recurring_payment_suspended_due_to_max_failed_payment':            # Here is the case where payment fails needs to be treated??            pass        # new payment        if data['txn_type'] == 'subscr_payment':            # get user data from the IPN            key_json = Signer.loads(data['custom'])            try:                # get the user                proxmate_user = User.objects.get(username=key_json['email'])            except:                return HttpResponse(                    json.dumps({                        'success': False,                        'error': 'Wrong Email'                    }), content_type="application/json"                )            # if not the correct receiver ID reject payment            if not data["receiver_id"] == settings.PAYPAL_MERCHANT_ID:                return HttpResponse(status=500)            if proxmate_user.profile.plan_expiration_date > datetime.now(pytz.utc):                # Still has some days left                days = settings.PROXMATE_PLANS[data['item_number']]['period']                proxmate_user.profile.plan_expiration_date = proxmate_user.profile.plan_expiration_date + timedelta(days=days)            else:                # has no days left so the subscription starts now                days = settings.PROXMATE_PLANS[data['item_number']]['period']                proxmate_user.profile.plan_expiration_date = datetime.now(pytz.utc) + timedelta(days=days)            # set status to subscribed and payment to paid(Need further thinking about this)            proxmate_user.profile.payment_status = 'paid'            proxmate_user.profile.subscription_status = 'subscribed'            proxmate_user.profile.save()            # save to payments            Payment.objects.create(                user=proxmate_user,                currency=data['mc_currency'],                amount=data['mc_gross'],                transaction_id=data['txn_id'],                payer_email=data['payer_email'],                description=data['transaction_subject'],                subscription_plan=data['item_number'],                subscription_id=data['subscr_id']            )        # new subscription signup        if data['txn_type'] == 'subscr_signup':            # get user data from IPN            key_json = Signer.loads(data['custom'])            try:                # identify user in database                proxmate_user = User.objects.get(username=key_json['email'])            except:                return HttpResponse(                    json.dumps({                        'success': False,                        'error': 'Wrong Email'                    }), content_type="application/json"                )            # existing user so attach email to account            if not proxmate_user.email:                proxmate_user.email = data['payer_email']                proxmate_user.save()            # check if subscription was not updated( 'sometimes payment comes first and sets that up')            if proxmate_user.profile.paypal_subscr_id != data['subscr_id']:                proxmate_user.profile.paypal_payer_id = data['payer_id']                proxmate_user.profile.paypal_subscr_id = data['subscr_id']                proxmate_user.profile.plan_status = data['item_number']                proxmate_user.profile.subscription_status = 'subscribed'                proxmate_user.profile.subscription_supplier = 'paypal'                proxmate_user.profile.save()            # Create subscription object            Subscription.objects.create(                user=proxmate_user,                payer_email=data['payer_email'],                description=data['item_name'],                subscription_plan=data['item_number'],                subscription_id=data['subscr_id'],                supplier="paypal"            )        # new One-Off Payment        if data['txn_type'] == 'web_accept':            # get user data from IPN            key_json = Signer.loads(data['custom'])            try:                proxmate_user = User.objects.get(username=key_json['email'])            except:                return HttpResponse(                    json.dumps({                        'success': False,                        'error': 'Wrong Email'                    }), content_type="application/json"                )            # existing user so attach email to account            if not proxmate_user.email:                proxmate_user.email = data['payer_email']                proxmate_user.save()            # if not the correct receiver ID            if not data["receiver_id"] == settings.PAYPAL_MERCHANT_ID:                return HttpResponse(status=500)            if proxmate_user.profile.plan_expiration_date > datetime.now(pytz.utc):                # Still has some days left                days = settings.PROXMATE_PLANS[data['item_number']]['period']                proxmate_user.profile.plan_expiration_date = proxmate_user.profile.plan_expiration_date + timedelta(days=days)            else:                # has no days left so the subscription starts now                days = settings.PROXMATE_PLANS[data['item_number']]['period']                proxmate_user.profile.plan_expiration_date = datetime.now(pytz.utc) + timedelta(days=days)            # set subscription data            proxmate_user.profile.paypal_payer_id = data['payer_id']            proxmate_user.profile.plan_status = data['item_number']            proxmate_user.profile.payment_status = 'paid'            proxmate_user.profile.subscription_status = 'subscription_canceled'            proxmate_user.profile.subscription_supplier = 'paypal'            proxmate_user.profile.save()            Payment.objects.create(                user=proxmate_user,                currency=data['mc_currency'],                amount=data['mc_gross'],                transaction_id=data['txn_id'],                payer_email=data['payer_email'],                description=data['transaction_subject'],                subscription_plan=data['item_number'],                subscription_id='None'            )            Subscription.objects.create(                user=proxmate_user,                payer_email=data['payer_email'],                description=data['transaction_subject'],                subscription_plan=data['item_number'],                subscription_id='None',                supplier="paypal"            )        # subscription cancellation        if data['txn_type'] == 'subscr_cancel':            try:                proxmate_user = User.objects.get(profile__paypal_subscr_id=data['subscr_id'])            except:                return HttpResponse(status=200)            proxmate_user.profile.paypal_subscr_id = ""            proxmate_user.profile.subscription_status = 'subscription_canceled'            proxmate_user.profile.plan_status = ""            proxmate_user.profile.save()        # subscription end of time        if data['txn_type'] == 'subscr_eot':            try:                proxmate_user = User.objects.get(profile__paypal_payer_id=data['payer_id'])            except:                return HttpResponse(status=200)            proxmate_user.profile.paypal_subscr_id = ""            proxmate_user.profile.subscription_status = 'subscription_canceled'            proxmate_user.profile.plan_status = ""            proxmate_user.profile.save()        return HttpResponse(status=200)class MessageApi(View):    @staticmethod    def post(request, key):        """        This API method returns list of messages to be shown in extension.        API endpoint: /api/message/list/<key>/        :param request: The request object doesn't receive any POST parameters.        :param key: The key is get from the URL path.        :return: Returns JSON object with list of messages        """        # check key validity        if not check_key(key):            return HttpResponse(                json.dumps({                    'success': False,                    'error': 'invalid_key'                }), content_type="application/json")        # get data from key        data = Signer.loads(key)        try:            user = User.objects.get(username=data['email'])        except User.DoesNotExist:            return HttpResponse(                json.dumps({                    'success': False,                })            )        _list = []        # get generic messages from cache        messages = message_cache.get('generic')        # retrieve messages as they are not in cache        if not messages:            messages = Message.objects.filter(                is_active=True,                is_generic=True            )            # put messages in cache            message_cache.set('generic', messages)        # create list of generic messages        for message in messages:            _list.append({                'timestamp': time.mktime(message.date_created.timetuple()),                'title': message.title,                'content': message.content,                'has_url': message.has_url,                'time_shown': message.time_shown,                'url': message.url,                'is_sticky': message.is_sticky,                'is_closable': message.is_closable,            })        # try to get messages from cache that are specific to user plan        messages = message_cache.get(user.profile.plan_status)        # no messages in cache        if not messages:            # get plan specific messages            messages = Message.objects.filter(                is_active=True,                is_generic=False,                specific_to_plan=user.profile.plan_status            )            # set messages in cache            message_cache.set(user.profile.plan_status, messages)        # append to list specific messages for user plan        for message in messages:            _list.append({                'timestamp': time.mktime(message.date_created.timetuple()),                'title': message.title,                'content': message.content,                'has_url': message.has_url,                'time_shown': message.time_shown,                'url': message.url,                'is_sticky': message.is_sticky,                'is_closable': message.is_closable,            })        return HttpResponse(            json.dumps({                'messages': _list,            })        )class ChangeCardApi(View):    @staticmethod    def post(request, key):        """        This API method to change credit card info based on token from stripe.        Not yet used        API endpoint: /api/stripe/card/<key>/        :param request: The request object gets the following POST parameters:                        - token: token generated from stripe containing        :param key: The key is get from the URL path.        :return: Returns JSON object with success status of the API execution        """        if not check_key(key):            return HttpResponse(                json.dumps({                    'success': False,                    'error': 'invalid_key'                }), content_type="application/json")        # get data from key        data = Signer.loads(key)        # identify user        try:            user = User.objects.get(username=data['email'])        except User.DoesNotExist:            return HttpResponse(                json.dumps({                    'success': False,                    'error': 'user_not_found'                })            )        # make sure has valid stripe customer id        if user.profile.subscription_supplier != 'stripe' and not user.profile.stripe_customer_id:            return HttpResponse(                json.dumps({                    'success': False,                    'error': 'invalid_customer'                })            )        # retrieve customer from stripe        customer = stripe.Customer.retrieve(user.profile.stripe_customer_id)        # get token from the request        token = json.loads(request.POST.get('token'))        # apply new card data        customer.source = token['id']        customer.save()        return HttpResponse(            json.dumps({                'success': True,            }), content_type="application/json"        )class UnsubscribeApi(View):    @staticmethod    def post(request, key):        """        This API unsubscribes a user        API endpoint: /api/unsubscribe/<key>/        :param request: The request object doesn't receive any POST parameters.        :param key: The key is get from the URL path.        :return: Returns JSON object with success status of the API execution        """        if not check_key(key):            return HttpResponse(                json.dumps({                    'success': False,                    'error': 'invalid_key'                }), content_type="application/json")        # get data from key        data = Signer.loads(key)        try:            user = User.objects.get(username=data['email'])        except User.DoesNotExist:            return HttpResponse(                json.dumps({                    'success': False,                    'error': 'user_not_found'                })            )        # checks for correct supplier        if user.profile.subscription_supplier != 'stripe' and user.profile.subscription_supplier != 'paypal':            return HttpResponse(                json.dumps({                    'success': False,                    'error': 'invalid_subscription'                })            )        # gets plan he is subscribed to        plan = user.profile.plan_status        # Stripe user        if user.profile.subscription_supplier == 'stripe' and user.profile.stripe_customer_id:            # get customer from stripe            customer = stripe.Customer.retrieve(user.profile.stripe_customer_id)            # get subscriptions and set false flag for active subscriptions            subscriptions = customer.subscriptions.all()            active_subscription = False            # check for active subscription            for subscription in subscriptions.data:                if subscription.status == 'active':                    active_subscription = subscription            # cancel the subscription when trial ends            if active_subscription:                active_subscription.delete(at_period_end=True)                user.profile.subscription_status = 'subscription_canceled'                user.profile.save()        # Paypal user with payer_id and subscription id        if user.profile.subscription_supplier == 'paypal' and user.profile.paypal_subscr_id:            # cancel the subscription            pay_pal.ManageRecurringPaymentsProfileStatus(user.profile.paypal_subscr_id, 'Cancel')            user.profile.subscription_status = 'subscription_canceled'            user.profile.save()        # no plan means no email for unsubscription        if not plan:            return HttpResponse(                json.dumps({                    'success': True,                }), content_type="application/json"            )        # get email template        with open('/opt/proxmate/static/emails/unsubscription_inline.html') as email_file:            email_template = string.Template(email_file.read())        # populate template with data        html_message = email_template.safe_substitute(            unsubscribedemail=str(user.email),            subsctiptionperiod=str(settings.PROXMATE_PLANS[plan]['period_name']),            expiretiondate=user.profile.plan_expiration_date.strftime("%d %B %Y"),            paymentplan=str(settings.PROXMATE_PLANS[plan]['price_string'])        )        # send unsubscribe email        send_mail(subject='Proxmate Unsubscription Link',                  plain_content='',                  html_content=html_message,                  to_list=user.email,                  from_list='support@proxmate.me')        return HttpResponse(            json.dumps({                'success': True,            }), content_type="application/json"        )